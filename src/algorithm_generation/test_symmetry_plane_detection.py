"""
Detect reflectional symmetries in a 3D point cloud. Implemented Algorithm based on (Hruda et. al.)[https://doi.org/10.1007/s00371-020-02034-w]
author: Sebastian Jost
"""
import numpy as np
import matplotlib.pyplot as plt
from symmetry_plane_detection import init_planes, reflect_symmetry_measure, reflect_points_across_plane, find_symmetry_planes, plane_point_normal2standard_form

def test_init_planes(X: np.ndarray, num_planes: int = 5, threshold: float = 0.1) -> list[tuple[np.ndarray, np.ndarray]]:
    """
    Given a set of points X, test the init_planes function by drawing the computed planes and points X in 3D.
    
    Args:
        X (np.ndarray): set of points
        num_planes (int): number of planes to generate
        threshold (float): threshold to check if a plane is too similar to existing planes
    
    Returns:
        list[tuple[np.ndarray, np.ndarray]]: list of planes (midpoint, normal vector) generated by init_planes()
    """
    planes: list[tuple[np.ndarray, np.ndarray]] = init_planes(X, num_planes, threshold)
    print(f"found {len(planes)} planes:")
    for plane in planes:
        print(plane)
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    # plot the planes
    for i, plane in enumerate(planes):
        # plot the plane
        draw_plane(ax, plane, show_normal=False)
        # draw_plane(ax, p, n, show_normal=False)
    set_equal_aspect_3d(ax)
    plt.title("Initial planes for symmetry detection")
    plt.show()
    return planes
    

# def test_symmetry_measure(X: np.ndarray, T: np.ndarray, alpha: float):
#     """
#     Given a set of points X, a transformation T and an alpha parameter, test the symmetry_measure function.
#     """

def test_reflect_points_across_plane(X: np.ndarray, plane: np.ndarray) -> np.ndarray:
    """
    Given a set of points X, a point p and a normal vector n, test the reflect_points_across_plane function.
    plot the points (blue) and the reflected points (red) in 3D.

    Args:
        X (np.ndarray): set of points
        p (np.ndarray): point on the plane
        n (np.ndarray): normal vector of the plane
        
    Returns:
        np.ndarray: reflected points (output of reflect_points_across_plane())
    """
    refkected_X = reflect_points_across_plane(X, plane)
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o', label='X')
    # plot the reflected points
    ax.scatter(refkected_X[:, 0], refkected_X[:, 1], refkected_X[:, 2], c='r', marker='o', label='reflected X')
    # plot the plane
    draw_plane(ax, plane, show_normal=True)
    # draw_plane(ax, p, n, show_normal=True)
    # configure plot
    set_equal_aspect_3d(ax)
    plt.title("Reflection of points across a plane")
    plt.legend(loc='upper center', ncol=2)
    plt.show()
    return refkected_X


def test_find_symmetry_planes(
        X: np.ndarray,
        num_planes: int = 1000,
        plane_similarity_threshold: float = 0.1,
        alpha: float = 1.0,
        S: int = 5,
    ) -> list[tuple[np.ndarray, np.ndarray]]:
    """
    Given a set of points X, test the find_symmetry_planes function by drawing the computed planes and points X in 3D.
    
    Args:
        X (np.ndarray): set of points
        num_planes (int): number of planes to generate
        threshold (float): threshold to check if a plane is too similar to existing planes
        alpha (float): parameter to control the similarity function
        S (int): number of best planes to keep
        
    Returns:
        list[tuple[np.ndarray, np.ndarray]]: list of best symmetry planes
    """
    best_planes = find_symmetry_planes(
        X=X,
        plane_similarity_threshold=plane_similarity_threshold,
        S=S,
        min_score_ratio=0.9,
        num_init_planes=num_planes,
        )
    print(f"found {len(best_planes)} best planes.")
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    # plot the best planes
    for i, plane in enumerate(best_planes):
        # plot the plane
        symmetry_measure = reflect_symmetry_measure(X, plane, alpha)
        print(f"Symmetry measure for plane {i}: {symmetry_measure}")
        draw_plane(ax, plane, show_normal=False)
    set_equal_aspect_3d(ax)
    plt.title("Best planes for symmetry detection")
    plt.show()
    draw_reflected_points(
        X=X,
        planes=best_planes,
    )
    return best_planes

def draw_reflected_points(X: np.ndarray, planes: list[tuple[np.ndarray, np.ndarray]]):
    """
    For all given planes, draw the reflected points in 3D one after the other. Wait for user input in between.
    """
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    plt.ion()
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    set_equal_aspect_3d(ax)
    # plot the planes
    for i, plane in enumerate(planes):
        # plot the plane
        ax_artists = draw_plane(ax, plane, show_normal=False)
        # draw the reflected points
        reflected_X = reflect_points_across_plane(X, plane)
        symmetry_measure: float = reflect_symmetry_measure(X, plane, alpha=1.0)
        print(f"Symmetry measure for plane {i}: {symmetry_measure:.3f}, plane: {plane}")
        ax_artists.append(ax.scatter(reflected_X[:, 0], reflected_X[:, 1], reflected_X[:, 2], c='r', marker='o'))
        plt.title(f"Reflected points for plane {i}")
        plt.pause(.1)
        input("Press Enter to continue...")
        # remove the last points
        for artist in ax_artists:
            artist.remove()



def draw_plane(
        ax: plt.Axes,
        plane: np.ndarray,
        size: float = 1,
        show_normal: bool = True,
        transparency: float = 1.0,
        ) -> list[plt.Artist]:
    """
    Draw a plane in 3D given in standard form (a, b, c, d) (ax + by + cz + d = 0).
    
    Args:
        ax (plt.Axes): matplotlib axis to plot on
        plane (np.ndarray): plane in standard form (a, b, c, d)
        size (float): size of the plane to draw
        show_normal (bool): whether to plot the normal vector
    """
    # Extract plane coefficients
    a, b, c, d = plane

    # Normal vector of the plane
    normal = np.array([a, b, c])

    # Ensure the normal vector is a unit vector
    normal = normal / np.linalg.norm(normal)

    # Find a support vector (a point on the plane)
    # We choose the point (x0, 0, 0) if a != 0
    if a != 0:
        support = np.array([-d / a, 0, 0])
    elif b != 0:
        support = np.array([0, -d / b, 0])
    elif c != 0:
        support = np.array([0, 0, -d / c])
    else:
        raise ValueError("Invalid plane coefficients. At least one of a, b, c must be non-zero.")
    
    # Define a grid in the plane
    d = np.linspace(-size, size, 10)
    D1, D2 = np.meshgrid(d, d)
    
    # Find a third vector perpendicular to the normal vector
    n1 = np.array([1, 0, 0])
    if np.allclose(normal, n1) or np.allclose(normal, -n1):
        n1 = np.array([0, 1, 0])
    v1 = np.cross(normal, n1)
    v1 /= np.linalg.norm(v1)
    
    # Find another vector in the plane
    v2 = np.cross(normal, v1)
    v2 /= np.linalg.norm(v2)
    
    ax_objects: list[plt.Artist] = []
    # Plane points
    plane_points = support + D1[..., np.newaxis] * v1 + D2[..., np.newaxis] * v2
    ax_objects.append(ax.plot_surface(plane_points[..., 0], plane_points[..., 1], plane_points[..., 2], color='g', alpha=transparency, rstride=100, cstride=100))

    if show_normal:
        # plot the normal vector
        ax_objects.append(ax.quiver(support[0], support[1], support[2], normal[0], normal[1], normal[2], color='r'))

    return ax_objects

def set_equal_aspect_3d(ax):
    """
    Sets equal scaling for all three axes of a 3D plot.

    Parameters:
    ax (Axes3D): A Matplotlib 3D Axes object.
    """
    # Get the current limits
    x_limits = ax.get_xlim()
    y_limits = ax.get_ylim()
    z_limits = ax.get_zlim()

    # Determine the new limits that make the axes scaled equally
    all_limits = np.array([x_limits, y_limits, z_limits])
    min_limit = all_limits[:, 0].min()
    max_limit = all_limits[:, 1].max()

    # Set the new limits
    ax.set_xlim([min_limit, max_limit])
    ax.set_ylim([min_limit, max_limit])
    ax.set_zlim([min_limit, max_limit])

    # Set the same scale for all axes
    ax.set_box_aspect([1, 1, 1])  # aspect ratio is 1:1:1

def dodecahedron_vertices():
    """
    Calculates the vertices of a regular dodecahedron centered at the origin 
    and with edge length 2.
    
    Returns:
        np.ndarray: A (20, 3) array where each row represents a vertex (x, y, z).
    """

    phi = (1 + np.sqrt(5)) / 2  # Golden ratio

    vertices = np.array([
        (1, 1, 1), (1, 1, -1), (1, -1, 1), (1, -1, -1),
        (-1, 1, 1), (-1, 1, -1), (-1, -1, 1), (-1, -1, -1),
        (0, phi, 1/phi), (0, phi, -1/phi), (0, -phi, 1/phi), (0, -phi, -1/phi),
        (1/phi, 0, phi), (1/phi, 0, -phi), (-1/phi, 0, phi), (-1/phi, 0, -phi),
        (phi, 1/phi, 0), (phi, -1/phi, 0), (-phi, 1/phi, 0), (-phi, -1/phi, 0)
    ])
    edges = np.array([
        (0, 8), (0, 12), (0, 16),
        (1, 9), (1, 13), (1, 16),
        (2, 10), (2, 12), (2, 17),
        (3, 11), (3, 13), (3, 17),
        (4, 8), (4, 14), (4, 18),
        (5, 9), (5, 15), (5, 18),
        (6, 10), (6, 14), (6, 19),
        (7, 11), (7, 15), (7, 19),
        (8, 9),
        (10, 11),
        (12, 14),
        (13, 15),
        (16, 17),
        (18, 19),
        ])

    return vertices, edges

def cube_2x2_stickers():
    offset_face = 1 + 2**0.5
    # offset_face = 2
    X = np.array([
        [ 1, 1, offset_face], # top face
        [ 1,-1, offset_face],
        [-1, 1, offset_face],
        [-1,-1, offset_face],
        [ 1, 1,-offset_face], # bottom face
        [ 1,-1,-offset_face],
        [-1, 1,-offset_face],
        [-1,-1,-offset_face],
        [ offset_face, 1, 1], # right face
        [ offset_face,-1, 1],
        [ offset_face, 1,-1],
        [ offset_face,-1,-1],
        [-offset_face, 1, 1], # left face
        [-offset_face,-1, 1],
        [-offset_face, 1,-1],
        [-offset_face,-1,-1],
        [ 1, offset_face, 1], # front face
        [ 1, offset_face,-1],
        [-1, offset_face, 1],
        [-1, offset_face,-1],
        [ 1,-offset_face, 1], # back face
        [ 1,-offset_face,-1],
        [-1,-offset_face, 1],
        [-1,-offset_face,-1],
    ])
    return X, None

def main():
    # # tetrahedron corners
    # X = np.array([
    #     [ 1, 0, 0],
    #     [ 0, 1, 0],
    #     [ 0, 0, 1],
    #     [ 0, 0, 0],
    # ])
    
    # regular tetrahedron
    # X = np.array([
    #     [ 0, 0, 0],
    #     [ 1, 1, 0],
    #     [ 1, 0, 1],
    #     [ 0, 1, 1],
    # ])
    # # Example: corners of a cube
    # X = np.array([
    #     [ 1, 1, 1],
    #     [ 1, 1,-1],
    #     [ 1,-1, 1],
    #     [ 1,-1,-1],
    #     [-1, 1, 1],
    #     [-1, 1,-1],
    #     [-1,-1, 1],
    #     [-1,-1,-1],
    # ])
    # X, edges = dodecahedron_vertices()
    X, edges = cube_2x2_stickers()
    # test_init_planes(X, num_planes=10, threshold=.01)
    
    # symmetry plane
    # support: np.ndarray = np.array([0, 0, 0])
    # normal: np.ndarray = np.array([1, -1, 0])
    # non-symmetry plane
    support: np.ndarray = np.array([.5, -2, 0])
    normal: np.ndarray = np.array([1, -1, 3])
    normal = normal / np.linalg.norm(normal)
    plane = plane_point_normal2standard_form(support, normal)
    symmetry: float = reflect_symmetry_measure(X, plane, alpha=1.0)
    # symmetry: float = reflect_symmetry_measure(X, (support, normal), alpha=1.0)
    print(f"Symmetry measure: {symmetry}")
    # test_reflect_points_across_plane(X, plane)
    
    # test_find_symmetry_planes(X, num_planes=5000, threshold=0.1, alpha=1.0, S=200)
    test_find_symmetry_planes(X, num_planes=5000, plane_similarity_threshold=0.2, alpha=1.0, S=20000)

if __name__ == "__main__":
    main()