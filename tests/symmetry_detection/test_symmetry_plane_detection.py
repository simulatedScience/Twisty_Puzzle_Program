"""
Detect reflectional symmetries in a 3D point cloud. Implemented Algorithm based on (Hruda et. al.)[https://doi.org/10.1007/s00371-020-02034-w]
author: Sebastian Jost
"""
import numpy as np
import matplotlib.pyplot as plt
from symmetry_plane_detection import init_planes, reflect_symmetry_measure, reflect_points_across_plane, find_symmetry_planes, plane_point_normal2standard_form

def test_init_planes(X: np.ndarray, num_planes: int = 5, threshold: float = 0.1) -> list[tuple[np.ndarray, np.ndarray]]:
    """
    Given a set of points X, test the init_planes function by drawing the computed planes and points X in 3D.
    
    Args:
        X (np.ndarray): set of points
        num_planes (int): number of planes to generate
        threshold (float): threshold to check if a plane is too similar to existing planes
    
    Returns:
        list[tuple[np.ndarray, np.ndarray]]: list of planes (midpoint, normal vector) generated by init_planes()
    """
    planes: list[tuple[np.ndarray, np.ndarray]] = init_planes(X, num_planes, threshold)
    print(f"found {len(planes)} planes.")
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    # plot the planes
    for i, plane in enumerate(planes):
        # plot the plane
        draw_plane(ax, plane, show_normal=False)
        # draw_plane(ax, p, n, show_normal=False)
    ax.set_box_aspect([1,1,1])
    plt.title("Initial planes for symmetry detection")
    plt.show()
    return planes
    

# def test_symmetry_measure(X: np.ndarray, T: np.ndarray, alpha: float):
#     """
#     Given a set of points X, a transformation T and an alpha parameter, test the symmetry_measure function.
#     """

def test_reflect_points_across_plane(X: np.ndarray, plane: np.ndarray) -> np.ndarray:
    """
    Given a set of points X, a point p and a normal vector n, test the reflect_points_across_plane function.
    plot the points (blue) and the reflected points (red) in 3D.

    Args:
        X (np.ndarray): set of points
        p (np.ndarray): point on the plane
        n (np.ndarray): normal vector of the plane
        
    Returns:
        np.ndarray: reflected points (output of reflect_points_across_plane())
    """
    refkected_X = reflect_points_across_plane(X, plane)
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o', label='X')
    # plot the reflected points
    ax.scatter(refkected_X[:, 0], refkected_X[:, 1], refkected_X[:, 2], c='r', marker='o', label='reflected X')
    # plot the plane
    draw_plane(ax, plane, show_normal=True)
    # draw_plane(ax, p, n, show_normal=True)
    # configure plot
    ax.set_box_aspect([1,1,1])
    plt.title("Reflection of points across a plane")
    plt.legend(loc='upper center', ncol=2)
    plt.show()
    return refkected_X


def test_find_symmetry_planes(
        X: np.ndarray,
        num_planes: int = 1000,
        threshold: float = 0.1,
        alpha: float = 1.0,
        S: int = 5,
    ) -> list[tuple[np.ndarray, np.ndarray]]:
    """
    Given a set of points X, test the find_symmetry_planes function by drawing the computed planes and points X in 3D.
    
    Args:
        X (np.ndarray): set of points
        num_planes (int): number of planes to generate
        threshold (float): threshold to check if a plane is too similar to existing planes
        alpha (float): parameter to control the similarity function
        S (int): number of best planes to keep
        
    Returns:
        list[tuple[np.ndarray, np.ndarray]]: list of best symmetry planes
    """
    best_planes = find_symmetry_planes(X, num_planes, threshold, alpha, S)
    print(f"found {len(best_planes)} best planes.")
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    # plot the best planes
    for i, (p, n) in enumerate(best_planes):
        # plot the plane
        symmetry = reflect_symmetry_measure(X, (p, n), alpha)
        print(f"Symmetry measure for plane {i}: {symmetry}")
        draw_plane(ax, p, n, show_normal=False)
    ax.set_box_aspect([1,1,1])
    plt.title("Best planes for symmetry detection")
    plt.show()
    return best_planes

def draw_plane(
        ax: plt.Axes,
        plane: np.ndarray,
        size: float = 1,
        show_normal: bool = True):
    """
    Draw a plane in 3D given in standard form (a, b, c, d) (ax + by + cz + d = 0).
    
    Args:
        ax (plt.Axes): matplotlib axis to plot on
        plane (np.ndarray): plane in standard form (a, b, c, d)
        size (float): size of the plane to draw
        show_normal (bool): whether to plot the normal vector
    """
    # Extract plane coefficients
    a, b, c, d = plane
    
    # Normal vector of the plane
    normal = np.array([a, b, c])
    
    # Ensure the normal vector is a unit vector
    normal = normal / np.linalg.norm(normal)
    
    # Find a support vector (a point on the plane)
    # We choose the point (x0, 0, 0) if a != 0
    if a != 0:
        support = np.array([-d / a, 0, 0])
    elif b != 0:
        support = np.array([0, -d / b, 0])
    elif c != 0:
        support = np.array([0, 0, -d / c])
    else:
        raise ValueError("Invalid plane coefficients. At least one of a, b, c must be non-zero.")
    
    # Define a grid in the plane
    d = np.linspace(-size, size, 10)
    D1, D2 = np.meshgrid(d, d)
    
    # Find a third vector perpendicular to the normal vector
    n1 = np.array([1, 0, 0])
    if np.allclose(normal, n1) or np.allclose(normal, -n1):
        n1 = np.array([0, 1, 0])
    v1 = np.cross(normal, n1)
    v1 /= np.linalg.norm(v1)
    
    # Find another vector in the plane
    v2 = np.cross(normal, v1)
    v2 /= np.linalg.norm(v2)
    
    # Plane points
    plane_points = support + D1[..., np.newaxis] * v1 + D2[..., np.newaxis] * v2
    ax.plot_surface(plane_points[..., 0], plane_points[..., 1], plane_points[..., 2], color='g', alpha=0.5, rstride=100, cstride=100)
    


# def draw_plane(
#         ax: plt.Axes,
#         p: np.ndarray,
#         n: np.ndarray,
#         size: float = 1,
#         show_normal: bool = True):
#     """
#     Draw a plane in 3D given a point p and a normal vector n.

#     Args:
#         ax (plt.Axes): matplotlib axis to plot on
#         p (np.ndarray): point on the plane
#         n (np.ndarray): normal vector of the plane
#     """
#     # Define a grid in the plane
#     d = np.linspace(-size, size, 10)
#     D1, D2 = np.meshgrid(d, d)
    
#     # Find a third vector perpendicular to the normal vector
#     n1 = np.array([1, 0, 0])
#     if np.allclose(n, n1) or np.allclose(n, -n1):
#         n1 = np.array([0, 1, 0])
#     v1 = np.cross(n, n1)
#     v1 /= np.linalg.norm(v1)
    
#     # Find another vector in the plane
#     v2 = np.cross(n, v1)
#     v2 /= np.linalg.norm(v2)
    
#     # Plane points
#     plane_points = p + D1[..., np.newaxis] * v1 + D2[..., np.newaxis] * v2
#     ax.plot_surface(plane_points[..., 0], plane_points[..., 1], plane_points[..., 2], color='g', alpha=0.5, rstride=100, cstride=100)

#     if show_normal:
#         # plot the normal vector
#         ax.quiver(p[0], p[1], p[2], n[0], n[1], n[2], color='r')


def main():
    # # tetrahedron corners
    # X = np.array([
    #     [ 1, 0, 0],
    #     [ 0, 1, 0],
    #     [ 0, 0, 1],
    #     [ 0, 0, 0],
    # ])
    
    # regular tetrahedron
    # X = np.array([
    #     [ 0, 0, 0],
    #     [ 1, 1, 0],
    #     [ 1, 0, 1],
    #     [ 0, 1, 1],
    # ])
    # # Example: corners of a cube
    X = np.array([
        [ 1, 1, 1],
        [ 1, 1,-1],
        [ 1,-1, 1],
        [ 1,-1,-1],
        [-1, 1, 1],
        [-1, 1,-1],
        [-1,-1, 1],
        [-1,-1,-1],
    ])
    test_init_planes(X, num_planes=3, threshold=1)
    
    # symmetry plane
    # support: np.ndarray = np.array([0, 0, 0])
    # normal: np.ndarray = np.array([1, -1, 0])
    # non-symmetry plane
    support: np.ndarray = np.array([.5, -2, 0])
    normal: np.ndarray = np.array([1, -1, 3])
    normal = normal / np.linalg.norm(normal)
    plane = plane_point_normal2standard_form(support, normal)
    symmetry: float = reflect_symmetry_measure(X, plane, alpha=1.0)
    # symmetry: float = reflect_symmetry_measure(X, (support, normal), alpha=1.0)
    print(f"Symmetry measure: {symmetry}")
    test_reflect_points_across_plane(X, plane)
    
    # test_find_symmetry_planes(X, num_planes=1000, threshold=0.1, alpha=1.0, S=9)

if __name__ == "__main__":
    main()