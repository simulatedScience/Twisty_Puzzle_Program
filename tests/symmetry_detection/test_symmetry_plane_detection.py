"""
Detect reflectional symmetries in a 3D point cloud. Implemented Algorithm based on (Hruda et. al.)[https://doi.org/10.1007/s00371-020-02034-w]
author: Sebastian Jost
"""
import numpy as np
import matplotlib.pyplot as plt
from symmetry_plane_detection import init_planes, symmetry_measure, reflect_points_across_plane, find_symmetry_planes

def test_init_planes(X: np.ndarray, num_planes: int = 5, threshold: float = 0.1) -> list[tuple[np.ndarray, np.ndarray]]:
    """
    Given a set of points X, test the init_planes function by drawing the computed planes and points X in 3D.
    
    Args:
        X (np.ndarray): set of points
        num_planes (int): number of planes to generate
        threshold (float): threshold to check if a plane is too similar to existing planes
    
    Returns:
        list[tuple[np.ndarray, np.ndarray]]: list of planes (midpoint, normal vector) generated by init_planes()
    """
    planes: list[tuple[np.ndarray, np.ndarray]] = init_planes(X, num_planes, threshold)
    print(f"found {len(planes)} planes.")
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    # plot the planes
    for i, (p, n) in enumerate(planes):
        # plot the plane
        draw_plane(ax, p, n, show_normal=False)
    plt.title("Initial planes for symmetry detection")
    plt.show()
    return planes
    

# def test_symmetry_measure(X: np.ndarray, T: np.ndarray, alpha: float):
#     """
#     Given a set of points X, a transformation T and an alpha parameter, test the symmetry_measure function.
#     """

def test_reflect_points_across_plane(X: np.ndarray, p: np.ndarray, n: np.ndarray) -> np.ndarray:
    """
    Given a set of points X, a point p and a normal vector n, test the reflect_points_across_plane function.
    plot the points (blue) and the reflected points (red) in 3D.

    Args:
        X (np.ndarray): set of points
        p (np.ndarray): point on the plane
        n (np.ndarray): normal vector of the plane
        
    Returns:
        np.ndarray: reflected points (output of reflect_points_across_plane())
    """
    refkected_X = reflect_points_across_plane(X, p, n)
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o', label='X')
    # plot the reflected points
    ax.scatter(refkected_X[:, 0], refkected_X[:, 1], refkected_X[:, 2], c='r', marker='o', label='reflected X')
    # plot the plane
    draw_plane(ax, p, n, show_normal=True)
    # configure plot
    ax.set_box_aspect([1,1,1])
    plt.title("Reflection of points across a plane")
    plt.legend(loc='upper center', ncol=2)
    plt.show()
    return refkected_X


def test_find_symmetry_planes(
        X: np.ndarray,
        num_planes: int = 1000,
        threshold: float = 0.1,
        alpha: float = 1.0,
        S: int = 5,
    ) -> list[tuple[np.ndarray, np.ndarray]]:
    """
    Given a set of points X, test the find_symmetry_planes function by drawing the computed planes and points X in 3D.
    
    Args:
        X (np.ndarray): set of points
        num_planes (int): number of planes to generate
        threshold (float): threshold to check if a plane is too similar to existing planes
        alpha (float): parameter to control the similarity function
        S (int): number of best planes to keep
        
    Returns:
        list[tuple[np.ndarray, np.ndarray]]: list of best symmetry planes
    """
    best_planes = find_symmetry_planes(X, num_planes, threshold, alpha, S)
    print(f"found {len(best_planes)} best planes.")
    # create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # plot the points
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c='b', marker='o')
    # plot the best planes
    for i, (p, n) in enumerate(best_planes):
        # plot the plane
        symmetry = symmetry_measure(X, (p, n), alpha)
        print(f"Symmetry measure for plane {i}: {symmetry}")
        draw_plane(ax, p, n, show_normal=False)
    plt.title("Best planes for symmetry detection")
    plt.show()
    return best_planes



def draw_plane(
        ax: plt.Axes,
        p: np.ndarray,
        n: np.ndarray,
        show_normal: bool = True):
    """
    Draw a plane in 3D given a point p and a normal vector n.

    Args:
        ax (plt.Axes): matplotlib axis to plot on
        p (np.ndarray): point on the plane
        n (np.ndarray): normal vector of the plane
    """
    # Define a grid in the plane
    d = np.linspace(-1, 1, 10)
    D1, D2 = np.meshgrid(d, d)
    
    # Find a third vector perpendicular to the normal vector
    n1 = np.array([1, 0, 0])
    if np.allclose(n, n1) or np.allclose(n, -n1):
        n1 = np.array([0, 1, 0])
    v1 = np.cross(n, n1)
    v1 /= np.linalg.norm(v1)
    
    # Find another vector in the plane
    v2 = np.cross(n, v1)
    v2 /= np.linalg.norm(v2)
    
    # Plane points
    plane_points = p + D1[..., np.newaxis] * v1 + D2[..., np.newaxis] * v2
    ax.plot_surface(plane_points[..., 0], plane_points[..., 1], plane_points[..., 2], color='g', alpha=0.5, rstride=100, cstride=100)

    if show_normal:
        # plot the normal vector
        ax.quiver(p[0], p[1], p[2], n[0], n[1], n[2], color='r')


def main():
    # # tetrahedron corners
    # X = np.array([
    #     [ 1, 0, 0],
    #     [ 0, 1, 0],
    #     [ 0, 0, 1],
    #     [ 0, 0, 0],
    # ])
    # Example: corners of a cube
    X = np.array([
        [ 1, 1, 1],
        [ 1, 1,-1],
        [ 1,-1, 1],
        [ 1,-1,-1],
        [-1, 1, 1],
        [-1, 1,-1],
        [-1,-1, 1],
        [-1,-1,-1],
    ])
    test_init_planes(X, num_planes=50, threshold=0.1)
    
    # symmetry plane
    # support: np.ndarray = np.array([0, 0, 0])
    # normal: np.ndarray = np.array([1, -1, 0])
    # non-symmetry plane
    support: np.ndarray = np.array([0, -2, 0])
    normal: np.ndarray = np.array([1, -1, 3])
    normal = normal / np.linalg.norm(normal)
    symmetry: float = symmetry_measure(X, (support, normal), alpha=1.0)
    print(f"Symmetry measure: {symmetry}")
    test_reflect_points_across_plane(X, support, normal)
    
    test_find_symmetry_planes(X, num_planes=1000, threshold=0.1, alpha=1.0, S=9)

if __name__ == "__main__":
    main()