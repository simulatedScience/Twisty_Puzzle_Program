"""
This module implements methods to calculate and print the number of states in a twisty puzzle.
Since exact computation is difficult, we instead calculate upper and lower bounds.
"""

from math import log10, factorial
from collections import Counter

import numpy as np
from sympy.combinatorics import Permutation
from sympy.combinatorics.perm_groups import PermutationGroup

def get_state_space_size(moves, n_points):
    """
    calculate the state space size of the puzzle generated by the given moves

    inputs:
    -------
        moves - (list) or (iter) - iterable containing moves as lists of cycles
        n_points - (int) - number of points (color stickers) in the puzzle
            this can be determined with `len(puzzle.solved_state)`

    returns:
    --------
        (int) - number of possible states of the puzzle
    """
    perms = list()
    for move in moves:
        perms.append(Permutation(move, size=n_points))
    perm_group = PermutationGroup(perms)
    return perm_group.order()

def _state_space_size_upper_bound(moves: list, n_points: int):
    """
    calculate the state space size of the puzzle generated by the given moves

    Args:
        moves (list): iterable containing moves as lists of cycles
        n_points (int): number of points (color stickers) in the puzzle
            this can be determined with `len(puzzle.solved_state)`

    Returns:
        (int): number of possible states of the puzzle
    """
    perms = list()
    for move in moves:
        perms.append(Permutation(move, size=n_points))
    perm_group = PermutationGroup(perms)
    return perm_group.order()

def calculate_permutations_of_indistinguishable_pieces(pieces, points):
    """
    Calculate the product of factorials of the sizes of equivalence classes of pieces.

    Inputs:
    -------
        pieces - (list of lists) - each sublist contains indices of points that form a piece.
        points - (np.array) - array of point colors as integers (color indices).

    Returns:
    --------
        (int) - the number of permutations of indistinguishable pieces.
    """
    # To differentiate pieces, we use a tuple of (number of points, sorted color counts)
    piece_types = []

    for piece in pieces:
        # Count the occurrences of each color
        color_count = Counter(points[piece])
        # Sort the items of the Counter by color to create a consistent representation
        sorted_color_count = tuple(sorted(color_count.items()))
        # Use the number of points and the color count as a unique identifier
        piece_types.append(sorted_color_count)
    
    # Count how many pieces are of each type
    piece_type_counts = Counter(piece_types)
    # count how often each count occurs to avoid calculating the same factorial multiple times
    factorial_powers = Counter(piece_type_counts.values())
    
    # Calculate the product of the factorials of these counts
    perm_factor = 1
    # we expect very small factorials (n! with n << 400, often n < 10)
    for count, power in factorial_powers.items():
        perm_factor *= factorial(count)**power
    
    return perm_factor

def _state_space_size_lower_bound(moves, pieces, points: np.ndarray, upper_bound: int | None = None):
    """
    Calculate the lower bound on the state space size of the puzzle.

    Inputs:
    -------
        moves - (list) or (iter) - iterable containing moves as lists of cycles
        # n_points - (int) - number of points (color stickers) in the puzzle
        pieces - (list of lists) - each sublist contains indices of points that form a piece
        points - (np.ndarray) - array of point color indices

    Returns:
    --------
        (int) - lower bound on the number of possible states of the puzzle
    """
    if upper_bound is None:
        n_points: int = len(points)
        upper_bound = _state_space_size_upper_bound(moves, n_points)
    perm_factor = calculate_permutations_of_indistinguishable_pieces(pieces, points)
    lower_bound = upper_bound // perm_factor
    return lower_bound

def state_action_size(moves, n_points):
    """
    calculate the number of possible state-action pairs in a puzzle
    """
    return len(moves) * get_state_space_size(moves, n_points)


def number_str(number):
    """
    adds commas to a given number to make large number more readable

    inputs:
    -------
        number - (int) or (float) - any number

    returns:
    --------
        (str) - number with added seperators every three digits for better readability
    """
    int_str = str(int(number))
    i = len(int_str)%3
    print_str = str(int_str[:i])
    if i == 0:
        print_str += int_str[:3]
        i = 3

    while i < len(int_str):
        print_str += "," + int_str[i:i+3]
        i += 3
    if isinstance(number, int):
        return print_str
    elif isinstance(number, float):
        float_str = str(number)
        return print_str + float_str[i:]


def approx_int(number, n_digits=3, max_unchanged=1e6):
    """
    approximates a large integer in scientific notation (i.e: 3*10^15)

    inputs:
    -------
        number - (int) - any integer
        n_digits - (int) - number of decimal digits in the approximation
        max_unchanged - (int) - smallest number that gets converted
            to scientific notation. Smaller numbers just get converted to strings.
    """
    if number < max_unchanged: #number below 'max_unchanged' remain unchanged
        return number_str(number)
    power_dict = {'0':'⁰', '1':'¹', '2':'²', '3':'³', '4':'⁴',
                  '5':'⁵', '6':'⁶', '7':'⁷', '8':'⁸', '9':'⁹'}
    power = int(log10(number))
    power_str = "•10"
    for n in str(power):
        power_str += (power_dict[n])
    return str(round(number/(10**power), ndigits=n_digits))+power_str




if __name__=="__main__":
    print(approx_int(5**5**5))
    r = [(39, 36, 38, 37), (64, 69, 66, 71), (65, 68, 67, 70), (87, 79, 94, 61), (86, 78, 95, 60), (10, 12, 18, 17), (16, 9, 14, 20), (15, 11, 13, 19), (63, 26, 82, 34, 73, 44, 90, 30), (62, 24, 83, 32, 72, 46, 91, 28), (81, 25, 74, 33, 88, 47, 56, 29), (31, 80, 27, 75, 35, 89, 45, 57)]

    r2 = [(37, 38, 36, 39), (71, 66, 69, 64), (70, 67, 68, 65), (61, 94, 79, 87), (60, 95, 78, 86), (17, 18, 12, 10), (20, 14, 9, 16), (19, 13, 11, 15), (30, 90, 44, 73, 34, 82, 26, 63), (28, 91, 46, 72, 32, 83, 24, 62), (29, 56, 47, 88, 33, 74, 25, 81), (57, 45, 89, 35, 75, 27, 80, 31)]

    t = [(28, 53, 42, 77, 33, 68, 36, 60), (31, 52, 40, 76, 34, 69, 38, 61), (71, 30, 59, 41, 51, 35, 79, 39), (70, 29, 58, 43, 50, 32, 78, 37), (17, 20, 4, 0), (15, 18, 2, 1), (16, 19, 3, 5), (26, 24, 27, 25), (82, 86, 80, 85), (83, 87, 81, 84), (74, 64, 62, 55), (75, 65, 63, 54)]

    t2 = [(60, 36, 68, 33, 77, 42, 53, 28), (61, 38, 69, 34, 76, 40, 52, 31), (39, 79, 35, 51, 41, 59, 30, 71), (37, 78, 32, 50, 43, 58, 29, 70), (0, 4, 20, 17), (1, 2, 18, 15), (5, 3, 19, 16), (25, 27, 24, 26), (85, 80, 86, 82), (84, 81, 87, 83), (55, 62, 64, 74), (54, 63, 65, 75)]

    f = [(62, 61, 56, 59), (58, 63, 60, 57), (52, 81, 71, 91), (53, 80, 70, 90), (30, 28, 31, 29), (18, 14, 22, 3), (20, 13, 21, 2), (19, 12, 23, 4), (87, 37, 66, 44, 93, 42, 55, 27), (54, 24, 86, 38, 67, 47, 92, 41), (84, 26, 64, 36, 94, 45, 48, 43), (85, 25, 65, 39, 95, 46, 49, 40)]

    f2 = [(59, 56, 61, 62), (57, 60, 63, 58), (91, 71, 81, 52), (90, 70, 80, 53), (29, 31, 28, 30), (3, 22, 14, 18), (2, 21, 13, 20), (4, 23, 12, 19), (27, 55, 42, 93, 44, 66, 37, 87), (41, 92, 47, 67, 38, 86, 24, 54), (43, 48, 45, 94, 36, 64, 26, 84), (40, 49, 46, 95, 39, 65, 25, 85)]

    l = [(41, 42, 40, 43), (55, 52, 48, 51), (54, 53, 49, 50), (84, 59, 93, 76), (85, 58, 92, 77), (4, 22, 8, 1), (3, 21, 7, 0), (2, 23, 6, 5), (81, 29, 56, 47, 88, 33, 74, 25), (27, 80, 31, 57, 45, 89, 35, 75), (83, 24, 62, 28, 91, 46, 72, 32), (82, 26, 63, 30, 90, 44, 73, 34)]

    l2 = [(43, 40, 42, 41), (51, 48, 52, 55), (50, 49, 53, 54), (76, 93, 59, 84), (77, 92, 58, 85), (1, 8, 22, 4), (0, 7, 21, 3), (5, 6, 23, 2), (25, 74, 33, 88, 47, 56, 29, 81), (75, 35, 89, 45, 57, 31, 80, 27), (32, 72, 46, 91, 28, 62, 24, 83), (34, 73, 44, 90, 30, 63, 26, 82)]

    b = [(35, 33, 34, 32), (74, 76, 72, 79), (75, 77, 73, 78), (83, 51, 88, 69), (82, 50, 89, 68), (1, 7, 10, 16), (0, 6, 9, 15), (5, 8, 11, 17), (84, 43, 48, 45, 94, 36, 64, 26), (85, 40, 49, 46, 95, 39, 65, 25), (54, 41, 92, 47, 67, 38, 86, 24), (27, 55, 42, 93, 44, 66, 37, 87)]

    b2 = [(32, 34, 33, 35), (79, 72, 76, 74), (78, 73, 77, 75), (69, 88, 51, 83), (68, 89, 50, 82), (16, 10, 7, 1), (15, 9, 6, 0), (17, 11, 8, 5), (26, 64, 36, 94, 45, 48, 43, 84), (25, 65, 39, 95, 46, 49, 40, 85), (24, 86, 38, 67, 47, 92, 41, 54), (87, 37, 66, 44, 93, 42, 55, 27)]

    d = [(44, 46, 45, 47), (91, 94, 88, 93), (90, 95, 89, 92), (56, 66, 72, 48), (57, 67, 73, 49), (12, 9, 8, 21), (13, 10, 6, 22), (14, 11, 7, 23), (30, 71, 39, 79, 35, 51, 41, 59), (29, 70, 37, 78, 32, 50, 43, 58), (28, 60, 36, 68, 33, 77, 42, 53), (31, 61, 38, 69, 34, 76, 40, 52)]

    d2 = [(47, 45, 46, 44), (93, 88, 94, 91), (92, 89, 95, 90), (48, 72, 66, 56), (49, 73, 67, 57), (21, 8, 9, 12), (22, 6, 10, 13), (23, 7, 11, 14), (59, 41, 51, 35, 79, 39, 71, 30), (58, 43, 50, 32, 78, 37, 70, 29), (53, 42, 77, 33, 68, 36, 60, 28), (52, 40, 76, 34, 69, 38, 61, 31)]

    moves = [r, t, f, l, b, d]
    print(approx_int(get_state_space_size(moves, 96)))
    print(number_str(get_state_space_size(moves, 96)))
